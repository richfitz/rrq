<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>rrq queue controller — rrq_controller • rrq</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="rrq queue controller — rrq_controller" />
<meta property="og:description" content="A queue controller.  Use this to interact with a queue/cluster." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rrq</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.2.12</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/mrc-ide/rrq/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>rrq queue controller</h1>
    <small class="dont-index">Source: <a href='https://github.com/mrc-ide/rrq/blob/master/R/rrq_controller.R'><code>R/rrq_controller.R</code></a></small>
    <div class="hidden name"><code>rrq_controller.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>A queue controller.  Use this to interact with a queue/cluster.</p>
    </div>

    <pre class="usage"><span class='fu'>rrq_controller</span><span class='op'>(</span><span class='va'>queue_id</span>, con <span class='op'>=</span> <span class='fu'>redux</span><span class='fu'>::</span><span class='fu'><a href='https://rdrr.io/pkg/redux/man/hiredis.html'>hiredis</a></span><span class='op'>(</span><span class='op'>)</span><span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>queue_id</th>
      <td><p>An identifier for the queue.  This will prefix all
keys in redis, so a prefix might be useful here depending on
your use case (e.g. <code>rrq:&lt;user&gt;:&lt;id&gt;</code>)</p></td>
    </tr>
    <tr>
      <th>con</th>
      <td><p>A redis connection</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="task-lifecycle"><a class="anchor" href="#task-lifecycle"></a>Task lifecycle</h2>

    

<ul>
<li><p>A task is queued with <code>$enqueue()</code>, at which point it becomes <code>PENDING</code></p></li>
<li><p>Once a worker selects the task to run, it becomes <code>RUNNING</code></p></li>
<li><p>If the task completes successfully without error it becomes <code>COMPLETE</code></p></li>
<li><p>If the task throws an error, it becomes <code>ERROR</code></p></li>
<li><p>If the worker was interrupted (e.g., by a message) the task
becomes <code>INTERRUPTED</code></p></li>
<li><p>If the worker crashes, possibly due to the task, <em>and</em> the worker runs
a heartbeat the task becomes <code>ORPHAN</code></p></li>
<li><p>The status of an unknown task is <code>MISSING</code></p></li>
</ul>

    <h2 class="hasAnchor" id="worker-lifecycle"><a class="anchor" href="#worker-lifecycle"></a>Worker lifecycle</h2>

    

<ul>
<li><p>A worker appears and is <code>IDLE</code></p></li>
<li><p>When running a task it is <code>BUSY</code></p></li>
<li><p>If it receives a <code>PAUSE</code> message it becomes <code>PAUSED</code> until it
receives a <code>RESUME</code> message</p></li>
<li><p>If it exits cleanly (e.g., via a <code>STOP</code> message or a timeout) it
becomes <code>EXITED</code></p></li>
<li><p>If it crashes and was running a heartbeat, it becomes <code>LOST</code></p></li>
</ul>

    <h2 class="hasAnchor" id="messages"><a class="anchor" href="#messages"></a>Messages</h2>

    


<p>Most of the time workers process tasks, but you can also send them
"messages". Messages take priority over tasks, so if a worker
becomes idle (by coming online or by finishing a task) it will
consume all available messages before starting on a new task,
even if both are available.</p>
<p>Each message has a "command" and may have "arguments" to that
command. The supported messages are:</p><ul>
<li><p><code>PING</code> (no args): "ping" the worker, if alive it will respond
with "PONG"</p></li>
<li><p><code>ECHO</code> (accepts an argument of a string): Print a string to the
terminal and log of the worker. Will respond with <code>OK</code> once the
message has been printed.</p></li>
<li><p><code>EVAL</code> (accepts a string or a quoted expression): Evaluate an
arbitrary R expression on the worker. Responds with the value of
this expression.</p></li>
<li><p><code>STOP</code> (accepts a string to print as the worker exits, defaults
to "BYE"): Tells the worker to stop.</p></li>
<li><p><code>INFO</code> (no args): Returns information about the worker (versions
of packages, hostname, pid, etc).</p></li>
<li><p><code>PAUSE</code> (no args): Tells the worker to stop accepting tasks
(until it receives a <code>RESUME</code> message). Messages are processed
as normal.</p></li>
<li><p><code>RESUME</code> (no args): Tells a paused worker to resume accepting
tasks.</p></li>
<li><p><code>REFRESH</code> (no args): Tells the worker to rebuild their
environment with the <code>create</code> method.</p></li>
<li><p><code>TIMEOUT_SET</code> (accepts a number, representing seconds): Updates
the worker timeout - the length of time after which it will exit
if it has not processed a task.</p></li>
<li><p><code>TIMEOUT_GET</code> (no args): Tells the worker to respond with its
current timeout.</p></li>
</ul>

    <h2 class="hasAnchor" id="bulk-interface-lapply-"><a class="anchor" href="#bulk-interface-lapply-"></a>Bulk interface (<code>lapply</code>)</h2>

    


<p>The bulk interface is a bit more complicated than the basic
<code>enqueue</code> interface. In the majority of cases you can ignore the
details and use the <code>lapply</code> method in much the same way as you
would in normal R. Assuming that <code>obj</code> is your <code>rrq_controller</code>
object, you might write:</p><pre><span class='va'>ans</span> <span class='op'>&lt;-</span> <span class='va'>obj</span><span class='op'>$</span><span class='fu'>lapply</span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>10</span>, <span class='va'>sqrt</span><span class='op'>)</span>
</pre>

<p>which will return the same thing as <code><a href='https://rdrr.io/r/base/lapply.html'>lapply(1:10, sqrt)</a></code> (provided
that you have a Redis server running and workers registered)</p>
<p>There is some sleight of hand here, though as we need to identify
that it is the <em>symbol</em> <code>sqrt</code> that matters there corresponding
to the builtin <a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a> function. You can make this more explicit
by passing in the name of the function using <code>$lapply_()</code></p><pre><span class='va'>ans</span> <span class='op'>&lt;-</span> <span class='va'>obj</span><span class='op'>$</span><span class='fu'>lapply</span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>10</span>, <span class='fu'><a href='https://rdrr.io/r/base/substitute.html'>quote</a></span><span class='op'>(</span><span class='va'>sqrt</span><span class='op'>)</span><span class='op'>)</span>
</pre>

<p>The same treatment applies to the dots; this is allowed:</p><pre><span class='va'>b</span> <span class='op'>&lt;-</span> <span class='fl'>2</span>
<span class='va'>ans</span> <span class='op'>&lt;-</span> <span class='va'>obj</span><span class='op'>$</span><span class='fu'>lapply</span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>10</span>, <span class='va'>log</span>, base <span class='op'>=</span> <span class='va'>b</span><span class='op'>)</span>
</pre>

<p>But this will look up the bindings of <code>log</code> and <code>b</code> in the context
in which the call is made. This may not always do what is
expected, so you can use the names directly:</p><pre><span class='va'>b</span> <span class='op'>&lt;-</span> <span class='fl'>2</span>
<span class='va'>ans</span> <span class='op'>&lt;-</span> <span class='va'>obj</span><span class='op'>$</span><span class='fu'>lapply_</span><span class='op'>(</span><span class='fl'>1</span><span class='op'>:</span><span class='fl'>10</span>, <span class='fu'><a href='https://rdrr.io/r/base/substitute.html'>quote</a></span><span class='op'>(</span><span class='va'>log</span><span class='op'>)</span>, base <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/substitute.html'>quote</a></span><span class='op'>(</span><span class='va'>b</span><span class='op'>)</span><span class='op'>)</span>
</pre>

    <h2 class="hasAnchor" id="public-fields"><a class="anchor" href="#public-fields"></a>Public fields</h2>

    <p><div class="r6-fields"></p><dl>
<dt><code>con</code></dt><dd><p>The redis connection</p></dd>

<dt><code>queue_id</code></dt><dd><p>The queue id used on creation</p></dd>

<dt><code>keys</code></dt><dd><p>Internally used keys</p></dd>

<dt><code>db</code></dt><dd><p>Internally used storr database</p></dd>

</dl><p></div></p>
    <h2 class="hasAnchor" id="methods"><a class="anchor" href="#methods"></a>Methods</h2>

    
<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Public methods</h3>

<ul>
<li><p><a href='#method-new'><code>rrq_controller_$new()</code></a></p></li>
<li><p><a href='#method-destroy'><code>rrq_controller_$destroy()</code></a></p></li>
<li><p><a href='#method-envir'><code>rrq_controller_$envir()</code></a></p></li>
<li><p><a href='#method-enqueue'><code>rrq_controller_$enqueue()</code></a></p></li>
<li><p><a href='#method-enqueue_'><code>rrq_controller_$enqueue_()</code></a></p></li>
<li><p><a href='#method-lapply'><code>rrq_controller_$lapply()</code></a></p></li>
<li><p><a href='#method-lapply_'><code>rrq_controller_$lapply_()</code></a></p></li>
<li><p><a href='#method-bulk_wait'><code>rrq_controller_$bulk_wait()</code></a></p></li>
<li><p><a href='#method-task_list'><code>rrq_controller_$task_list()</code></a></p></li>
<li><p><a href='#method-task_status'><code>rrq_controller_$task_status()</code></a></p></li>
<li><p><a href='#method-task_progress'><code>rrq_controller_$task_progress()</code></a></p></li>
<li><p><a href='#method-task_overview'><code>rrq_controller_$task_overview()</code></a></p></li>
<li><p><a href='#method-task_position'><code>rrq_controller_$task_position()</code></a></p></li>
<li><p><a href='#method-task_preceeding'><code>rrq_controller_$task_preceeding()</code></a></p></li>
<li><p><a href='#method-task_result'><code>rrq_controller_$task_result()</code></a></p></li>
<li><p><a href='#method-tasks_result'><code>rrq_controller_$tasks_result()</code></a></p></li>
<li><p><a href='#method-task_wait'><code>rrq_controller_$task_wait()</code></a></p></li>
<li><p><a href='#method-tasks_wait'><code>rrq_controller_$tasks_wait()</code></a></p></li>
<li><p><a href='#method-task_delete'><code>rrq_controller_$task_delete()</code></a></p></li>
<li><p><a href='#method-task_cancel'><code>rrq_controller_$task_cancel()</code></a></p></li>
<li><p><a href='#method-task_data'><code>rrq_controller_$task_data()</code></a></p></li>
<li><p><a href='#method-queue_length'><code>rrq_controller_$queue_length()</code></a></p></li>
<li><p><a href='#method-queue_list'><code>rrq_controller_$queue_list()</code></a></p></li>
<li><p><a href='#method-queue_remove'><code>rrq_controller_$queue_remove()</code></a></p></li>
<li><p><a href='#method-worker_len'><code>rrq_controller_$worker_len()</code></a></p></li>
<li><p><a href='#method-worker_list'><code>rrq_controller_$worker_list()</code></a></p></li>
<li><p><a href='#method-worker_list_exited'><code>rrq_controller_$worker_list_exited()</code></a></p></li>
<li><p><a href='#method-worker_info'><code>rrq_controller_$worker_info()</code></a></p></li>
<li><p><a href='#method-worker_status'><code>rrq_controller_$worker_status()</code></a></p></li>
<li><p><a href='#method-worker_log_tail'><code>rrq_controller_$worker_log_tail()</code></a></p></li>
<li><p><a href='#method-worker_task_id'><code>rrq_controller_$worker_task_id()</code></a></p></li>
<li><p><a href='#method-worker_delete_exited'><code>rrq_controller_$worker_delete_exited()</code></a></p></li>
<li><p><a href='#method-worker_stop'><code>rrq_controller_$worker_stop()</code></a></p></li>
<li><p><a href='#method-worker_detect_exited'><code>rrq_controller_$worker_detect_exited()</code></a></p></li>
<li><p><a href='#method-worker_process_log'><code>rrq_controller_$worker_process_log()</code></a></p></li>
<li><p><a href='#method-worker_config_save'><code>rrq_controller_$worker_config_save()</code></a></p></li>
<li><p><a href='#method-worker_config_list'><code>rrq_controller_$worker_config_list()</code></a></p></li>
<li><p><a href='#method-worker_config_read'><code>rrq_controller_$worker_config_read()</code></a></p></li>
<li><p><a href='#method-worker_load'><code>rrq_controller_$worker_load()</code></a></p></li>
<li><p><a href='#method-message_send'><code>rrq_controller_$message_send()</code></a></p></li>
<li><p><a href='#method-message_has_response'><code>rrq_controller_$message_has_response()</code></a></p></li>
<li><p><a href='#method-message_get_response'><code>rrq_controller_$message_get_response()</code></a></p></li>
<li><p><a href='#method-message_response_ids'><code>rrq_controller_$message_response_ids()</code></a></p></li>
<li><p><a href='#method-message_send_and_wait'><code>rrq_controller_$message_send_and_wait()</code></a></p></li>
</ul>
<p><hr>
<a id="method-new"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>new()</code></h3>
<p>Constructor (called by <code>rrq_controller()</code>)</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>new</span><span class='op'>(</span><span class='va'>queue_id</span>, <span class='va'>con</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>queue_id</code></dt><dd><p>An identifier for the queue</p></dd>

<dt><code>con</code></dt><dd><p>A redis connection</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-destroy"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>destroy()</code></h3>
<p>Entirely destroy a queue, by deleting all keys
associated with it from the Redis database. This is a very
destructive action and cannot be undone.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>destroy</span><span class='op'>(</span>
  delete <span class='op'>=</span> <span class='cn'>TRUE</span>,
  worker_stop_type <span class='op'>=</span> <span class='st'>"message"</span>,
  worker_stop_timeout <span class='op'>=</span> <span class='fl'>0</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>delete</code></dt><dd><p>Either <code>TRUE</code> (the default) indicating that the
keys should be immediately deleted. Alternatively, provide an
integer value and the keys will instead be marked for future
deletion by "expiring" after this many seconds, using Redis'
<code>EXPIRE</code> command.</p></dd>

<dt><code>worker_stop_type</code></dt><dd><p>Passed to <code>$worker_stop</code>; Can be one of
"message", "kill" or "kill_local". The "kill" method requires that
the workers are using a heartbeat, and "kill_local" requires that
the workers are on the same machine as the controller. However,
these may be faster to stop workers than "message", which will
wait until any task is finished.</p></dd>

<dt><code>worker_stop_timeout</code></dt><dd><p>A timeout to pass to the worker if
using <code>type = "message"</code></p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-envir"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>envir()</code></h3>
<p>Register a function to create an environment when
creating a worker. When a worker starts, they will run this
function.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>envir</span><span class='op'>(</span><span class='va'>create</span>, notify <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>create</code></dt><dd><p>A function that will create an environment. It will
be called with no parameters, in a fresh R session.</p></dd>

<dt><code>notify</code></dt><dd><p>Boolean, indicating if we should send a <code>REFRESH</code>
message to all workers to update their environment.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-enqueue"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>enqueue()</code></h3>
<p>Queue an expression</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>enqueue</span><span class='op'>(</span>
  <span class='va'>expr</span>,
  envir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>parent.frame</a></span><span class='op'>(</span><span class='op'>)</span>,
  key_complete <span class='op'>=</span> <span class='cn'>NULL</span>,
  queue <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>expr</code></dt><dd><p>Any R expression, unevaluated</p></dd>

<dt><code>envir</code></dt><dd><p>The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is <code><a href='https://rdrr.io/r/base/sum.html'>sum(1 + a)</a></code>, we will also send
the value of <code>a</code> to the worker along with the expression.</p></dd>

<dt><code>key_complete</code></dt><dd><p>The name of a Redis key to write to once the
task is complete. You can use this with <code>$task_wait</code> to efficiently
wait for the task to complete (i.e., without using a busy loop).</p></dd>

<dt><code>queue</code></dt><dd><p>The queue to add the task to; if not specified the
"default" queue (which all workers listen to) will be
used. If you have configured workers to listen to more than
one queue you can specify that here. Be warned that if you
push jobs onto a queue with no worker, it will queue forever.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-enqueue_"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>enqueue_()</code></h3>
<p>Queue an expression</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>enqueue_</span><span class='op'>(</span>
  <span class='va'>expr</span>,
  envir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>parent.frame</a></span><span class='op'>(</span><span class='op'>)</span>,
  key_complete <span class='op'>=</span> <span class='cn'>NULL</span>,
  queue <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>expr</code></dt><dd><p>Any R expression, quoted; use this to use <code>$enqueue</code>
in a programmatic context where you want to construct expressions
directly (e.g., <code><a href='https://rdrr.io/r/base/bquote.html'>bquote(log(.(x)), list(x = 10))</a></code></p></dd>

<dt><code>envir</code></dt><dd><p>The environment that you would run this expression in
locally. This will be used to copy across any dependent variables.
For example, if your expression is <code><a href='https://rdrr.io/r/base/sum.html'>sum(1 + a)</a></code>, we will also send
the value of <code>a</code> to the worker along with the expression.</p></dd>

<dt><code>key_complete</code></dt><dd><p>The name of a Redis key to write to once the
task is complete. You can use this in conjunction with something
like <code>BLPOP</code> to wait until a task is complete without a busy (sleep)
loop.</p></dd>

<dt><code>queue</code></dt><dd><p>The queue to add the task to; if not specified the
"default" queue (which all workers listen to) will be
used. If you have configured workers to listen to more than
one queue you can specify that here. Be warned that if you
push jobs onto a queue with no worker, it will queue forever.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-lapply"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code><a href='https://rdrr.io/r/base/lapply.html'>lapply()</a></code></h3>
<p>Apply a function over a list of data. This is
equivalent to using <code>$enqueue()</code> over each element in the list.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>lapply</span><span class='op'>(</span>
  <span class='va'>x</span>,
  <span class='va'>fun</span>,
  <span class='va'>...</span>,
  dots <span class='op'>=</span> <span class='cn'>NULL</span>,
  envir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>parent.frame</a></span><span class='op'>(</span><span class='op'>)</span>,
  queue <span class='op'>=</span> <span class='cn'>NULL</span>,
  timeout <span class='op'>=</span> <span class='cn'>Inf</span>,
  time_poll <span class='op'>=</span> <span class='cn'>NULL</span>,
  progress <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>x</code></dt><dd><p>A list of data to apply our function against</p></dd>

<dt><code>fun</code></dt><dd><p>A function to be applied to each element of <code>x</code></p></dd>

<dt><code>...</code></dt><dd><p>Additional arguments to <code>fun</code></p></dd>

<dt><code>dots</code></dt><dd><p>As an alternative to <code>...</code>, you can provide the dots
as a list of additional arguments. This may be easier to program
against.</p></dd>

<dt><code>envir</code></dt><dd><p>The environment to use to try and find the function</p></dd>

<dt><code>queue</code></dt><dd><p>The queue to add the tasks to (see <code>$enqueue</code> for
details).</p></dd>

<dt><code>timeout</code></dt><dd><p>Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.</p></dd>

<dt><code>time_poll</code></dt><dd><p>Optional time with which to "poll" for
completion.</p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-lapply_"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>lapply_()</code></h3>
<p>The "standard evaluation" version of <code>$lapply()</code>.
This differs in how the function is found and how dots are passed.
With this version, both are passed by value; this may create more
overhead on the redis server as the values of the variables will
be copied over rather than using their names if possible.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>lapply_</span><span class='op'>(</span>
  <span class='va'>x</span>,
  <span class='va'>fun</span>,
  <span class='va'>...</span>,
  dots <span class='op'>=</span> <span class='cn'>NULL</span>,
  envir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>parent.frame</a></span><span class='op'>(</span><span class='op'>)</span>,
  queue <span class='op'>=</span> <span class='cn'>NULL</span>,
  timeout <span class='op'>=</span> <span class='cn'>Inf</span>,
  time_poll <span class='op'>=</span> <span class='cn'>NULL</span>,
  progress <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>x</code></dt><dd><p>A list of data to apply our function against</p></dd>

<dt><code>fun</code></dt><dd><p>A function to be applied to each element of <code>x</code></p></dd>

<dt><code>...</code></dt><dd><p>Additional arguments to <code>fun</code></p></dd>

<dt><code>dots</code></dt><dd><p>As an alternative to <code>...</code>, you can provide the dots
as a list of additional arguments. This may be easier to program
against.</p></dd>

<dt><code>envir</code></dt><dd><p>The environment to use to try and find the function</p></dd>

<dt><code>queue</code></dt><dd><p>The queue to add the tasks to (see <code>$enqueue</code> for
details).</p></dd>

<dt><code>timeout</code></dt><dd><p>Optional timeout, in seconds, after which an
error will be thrown if the task has not completed. If a
timeout is given as <code>0</code>, then we return a handle that can be used
to check for tasks using <code>bulk_wait</code></p></dd>

<dt><code>time_poll</code></dt><dd><p>Optional time with which to "poll" for
completion.</p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-bulk_wait"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>bulk_wait()</code></h3>
<p>Wait for a group of tasks</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>bulk_wait</span><span class='op'>(</span><span class='va'>x</span>, timeout <span class='op'>=</span> <span class='cn'>Inf</span>, time_poll <span class='op'>=</span> <span class='cn'>NULL</span>, progress <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>x</code></dt><dd><p>An object of class <code>rrq_bulk</code>, as created by <code>$lapply()</code></p></dd>

<dt><code>timeout</code></dt><dd><p>Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.</p></dd>

<dt><code>time_poll</code></dt><dd><p>Optional time with which to "poll" for
completion.</p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_list"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_list()</code></h3>
<p>List ids of all tasks known to this rrq controller</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_list</span><span class='op'>(</span><span class='op'>)</span></pre><p></div></p>

<p><hr>
<a id="method-task_status"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_status()</code></h3>
<p>Return a character vector of task statuses. The name
of each element corresponds to a task id, and the value will be
one of the possible statuses ("PENDING", "COMPLETE", etc).</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_status</span><span class='op'>(</span>task_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_ids</code></dt><dd><p>Optional character vector of task ids for which you
would like statuses. If not given (or <code>NULL</code>) then the status of
all task ids known to this rrq controller is returned.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_progress"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_progress()</code></h3>
<p>Retrieve task progress, if set. This will be <code>NULL</code>
if progress has never been registered, otherwise whatever value
was set - can be an arbitrary R object.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_progress</span><span class='op'>(</span><span class='va'>task_id</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_id</code></dt><dd><p>A single task id for which the progress is wanted.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_overview"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_overview()</code></h3>
<p>Provide a high level overview of task statuses
for a set of task ids, being the count in major categories of
<code>PENDING</code>, <code>RUNNING</code>, <code>COMPLETE</code> and <code>ERROR</code>.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_overview</span><span class='op'>(</span>task_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_ids</code></dt><dd><p>Optional character vector of task ids for which you
would like the overview. If not given (or <code>NULL</code>) then the status of
all task ids known to this rrq controller is used.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_position"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_position()</code></h3>
<p>Find the position of one or more tasks in the queue.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_position</span><span class='op'>(</span><span class='va'>task_ids</span>, missing <span class='op'>=</span> <span class='fl'>0L</span>, queue <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_ids</code></dt><dd><p>Character vector of tasks to find the position for.</p></dd>

<dt><code>missing</code></dt><dd><p>Value to return if the task is not found in the queue.
A task will take value <code>missing</code> if it is running, complete,
errored etc and a positive integer if it is in the queue,
indicating its position (with 1) being the next task to run.</p></dd>

<dt><code>queue</code></dt><dd><p>The name of the queue to query (defaults to the
"default" queue).</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_preceeding"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_preceeding()</code></h3>
<p>List the tasks in front of <code>task_id</code> in the queue.
If the task is missing from the queue this will return NULL. If
the task is next in the queue this will return an empty character
vector.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_preceeding</span><span class='op'>(</span><span class='va'>task_id</span>, queue <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_id</code></dt><dd><p>Task to find the position for.</p></dd>

<dt><code>queue</code></dt><dd><p>The name of the queue to query (defaults to the
"default" queue).</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_result"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_result()</code></h3>
<p>Get the result for a single task (see <code>$tasks_result</code>
for a method for efficiently getting multiple results at once).
Returns the value of running the task if it is complete, and an
error otherwise.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_result</span><span class='op'>(</span><span class='va'>task_id</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_id</code></dt><dd><p>The single id for which the result is wanted.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-tasks_result"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>tasks_result()</code></h3>
<p>Get the results of a group of tasks, returning them as a
list.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>tasks_result</span><span class='op'>(</span><span class='va'>task_ids</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_ids</code></dt><dd><p>A vector of task ids for which the task result
is wanted.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_wait"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_wait()</code></h3>
<p>Poll for a task to complete, returning the result
when completed. If the task has already completed this is
roughly equivalent to <code>task_result</code>. See <code>$tasks_wait</code> for an
efficient way of doing this for a group of tasks.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_wait</span><span class='op'>(</span>
  <span class='va'>task_id</span>,
  timeout <span class='op'>=</span> <span class='cn'>Inf</span>,
  time_poll <span class='op'>=</span> <span class='cn'>NULL</span>,
  progress <span class='op'>=</span> <span class='cn'>NULL</span>,
  key_complete <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_id</code></dt><dd><p>The single id that we will wait for</p></dd>

<dt><code>timeout</code></dt><dd><p>Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.</p></dd>

<dt><code>time_poll</code></dt><dd><p>Optional time with which to "poll" for
completion. The default and behaviour depend on <code>key_complete</code> -
see the details section.</p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

<dt><code>key_complete</code></dt><dd><p>Optional key used when <code>enqueing</code> the tasks
that will be written to on completion.</p></dd>

</dl><p></div></p>
<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Details</h4>
<p>The polling behaviour depends on <code>key_complete</code>. If
<code>key_complete</code> is <code>NULL</code> then we use a busy-loop, sleeping for
<code>time_poll</code> seconds between polls of Redis. As such, the smaller
the <code>time_poll</code> the faster you will get your result, as it may
be delayed by up to <code>time_poll</code>, but the heavier the network and
Redis load (the default is 0.05s). Alternatively, if
<code>key_complete</code> is given then your task will be returned as soon
as it is written into Redis, and <code>time_poll</code> is the time between
subsequent calls to the Redis function that enables
this. Shorter values of <code>time_poll</code> then make R more responsive
to being interrupted and longer values reduce network load (the
default is 1s)</p>

<p><hr>
<a id="method-tasks_wait"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>tasks_wait()</code></h3>
<p>Poll for a group of tasks to complete, returning the
result as list when completed. If the tasks have already completed
this is roughly equivalent to <code>tasks_result</code>.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>tasks_wait</span><span class='op'>(</span>
  <span class='va'>task_ids</span>,
  timeout <span class='op'>=</span> <span class='cn'>Inf</span>,
  time_poll <span class='op'>=</span> <span class='cn'>NULL</span>,
  progress <span class='op'>=</span> <span class='cn'>NULL</span>,
  key_complete <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_ids</code></dt><dd><p>A vector of task ids to poll for</p></dd>

<dt><code>timeout</code></dt><dd><p>Optional timeout, in seconds, after which an
error will be thrown if the task has not completed.</p></dd>

<dt><code>time_poll</code></dt><dd><p>Optional time with which to "poll" for
completion. The default and behaviour depend on <code>key_complete</code> -
see the details section of <code>$task_wait</code></p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

<dt><code>key_complete</code></dt><dd><p>Optional key used when <code>enqueing</code> the tasks
that will be written to on completion. If used, then all tasks
must share the same completion key.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_delete"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_delete()</code></h3>
<p>Delete one or more tasks</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_delete</span><span class='op'>(</span><span class='va'>task_ids</span>, check <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_ids</code></dt><dd><p>Vector of task ids to delete</p></dd>

<dt><code>check</code></dt><dd><p>Logical indicating if we should check that the tasks
are not running. Deleting running tasks is unlikely to result in
desirable behaviour.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-task_cancel"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_cancel()</code></h3>
<p>Cancel a single task. If the task is <code>PENDING</code> it
will be deleted. If <code>RUNNING</code> then the worker will be
interrupted if it supports this.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_cancel</span><span class='op'>(</span><span class='va'>task_id</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_id</code></dt><dd><p>Id of the task to cancel</p></dd>

</dl><p></div></p>
<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Returns</h4>
<p>TRUE if successfully cancelled, otherwise throws an error with
task_id and status e.g. Task 123 is not running (MISSING)</p>
<p><hr>
<a id="method-task_data"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>task_data()</code></h3>
<p>Fetch internal data about a task from Redis
(expert use only).</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>task_data</span><span class='op'>(</span><span class='va'>task_id</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_id</code></dt><dd><p>The id of the task</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-queue_length"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>queue_length()</code></h3>
<p>Returns the number of tasks in the queue (waiting for
an available worker).</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>queue_length</span><span class='op'>(</span>queue <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>queue</code></dt><dd><p>The name of the queue to query (defaults to the
"default" queue).</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-queue_list"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>queue_list()</code></h3>
<p>Returns the keys in the task queue.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>queue_list</span><span class='op'>(</span>queue <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>queue</code></dt><dd><p>The name of the queue to query (defaults to the
"default" queue).</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-queue_remove"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>queue_remove()</code></h3>
<p>Remove task ids from a queue.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>queue_remove</span><span class='op'>(</span><span class='va'>task_ids</span>, queue <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>task_ids</code></dt><dd><p>Task ids to remove</p></dd>

<dt><code>queue</code></dt><dd><p>The name of the queue to query (defaults to the
"default" queue).</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_len"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_len()</code></h3>
<p>Returns the number of active workers</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_len</span><span class='op'>(</span><span class='op'>)</span></pre><p></div></p>

<p><hr>
<a id="method-worker_list"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_list()</code></h3>
<p>Returns the ids of active workers</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_list</span><span class='op'>(</span><span class='op'>)</span></pre><p></div></p>

<p><hr>
<a id="method-worker_list_exited"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_list_exited()</code></h3>
<p>Returns the ids of workers known to have exited</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_list_exited</span><span class='op'>(</span><span class='op'>)</span></pre><p></div></p>

<p><hr>
<a id="method-worker_info"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_info()</code></h3>
<p>Returns a list of information about active
workers (or exited workers if <code>worker_ids</code> includes them).</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_info</span><span class='op'>(</span>worker_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers are used.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_status"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_status()</code></h3>
<p>Returns a character vector of current worker statuses</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_status</span><span class='op'>(</span>worker_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers are used.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_log_tail"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_log_tail()</code></h3>
<p>Returns the last (few) elements in the worker
log. The log will be returned as a <a href='https://rdrr.io/r/base/data.frame.html'>data.frame</a> of entries
<code>worker_id</code> (the worker id), <code>time</code> (the time in Redis when the
event happened; see <a href='https://rdrr.io/pkg/redux/man/redis_time.html'>redux::redis_time</a> to convert this to an R
time), <code>command</code> (the worker command) and <code>message</code> (the message
corresponding to that command).</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_log_tail</span><span class='op'>(</span>worker_ids <span class='op'>=</span> <span class='cn'>NULL</span>, n <span class='op'>=</span> <span class='fl'>1</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers are used.</p></dd>

<dt><code>n</code></dt><dd><p>Number of elements to select, the default being the single
last entry. Use <code>Inf</code> or <code>0</code> to indicate that you want all log entries</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_task_id"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_task_id()</code></h3>
<p>Returns the task id that each worker is working on,
if any.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_task_id</span><span class='op'>(</span>worker_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers are used.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_delete_exited"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_delete_exited()</code></h3>
<p>Cleans up workers known to have exited</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_delete_exited</span><span class='op'>(</span>worker_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
rrq looks for exited workers.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_stop"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_stop()</code></h3>
<p>Stop workers.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_stop</span><span class='op'>(</span>
  worker_ids <span class='op'>=</span> <span class='cn'>NULL</span>,
  type <span class='op'>=</span> <span class='st'>"message"</span>,
  timeout <span class='op'>=</span> <span class='fl'>0</span>,
  time_poll <span class='op'>=</span> <span class='fl'>1</span>,
  progress <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers will be stopped.</p></dd>

<dt><code>type</code></dt><dd><p>The strategy used to stop the workers. Can be <code>message</code>,
<code>kill</code> or <code>kill_local</code> (see details).</p></dd>

<dt><code>timeout</code></dt><dd><p>Optional timeout; if greater than zero then we poll
for a response from the worker for this many seconds until they
acknowledge the message and stop (only has an effect if <code>type</code>
is <code>message</code>).</p></dd>

<dt><code>time_poll</code></dt><dd><p>If <code>type</code> is <code>message</code> and <code>timeout</code> is greater
than zero, this is the polling interval used between redis calls.
Increasing this reduces network load but decreases the ability
to interrupt the process.</p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

</dl><p></div></p>
<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Details</h4>
<p>The <code>type</code> parameter indicates the strategy used to stop
workers, and interacts with other parameters. The strategies used by
the different values are:</p><ul>
<li><p><code>message</code>, in which case a <code>STOP</code> message will be sent to the
worker, which they will receive after finishing any currently
running task (if <code>RUNNING</code>; <code>IDLE</code> workers will stop immediately).</p></li>
<li><p><code>kill</code>, in which case a kill signal will be sent via the heartbeat
(if the worker is using one). This will kill the worker even if
is currently working on a task, eventually leaving that task with
a status of <code>ORPHAN</code>.</p></li>
<li><p><code>kill_local</code>, in which case a kill signal is sent using operating
system signals, which requires that the worker is on the same
machine as the controller.</p></li>
</ul>


<p><hr>
<a id="method-worker_detect_exited"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_detect_exited()</code></h3>
<p>Detects exited workers through a lapsed heartbeat</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_detect_exited</span><span class='op'>(</span><span class='op'>)</span></pre><p></div></p>

<p><hr>
<a id="method-worker_process_log"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_process_log()</code></h3>
<p>Return the contents of a worker's process log, if
it is located on the same physical storage (including network
storage) as the controller. This will generally behave for
workers started with <a href='worker_spawn.html'>worker_spawn</a> but may require significant
care otherwise.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_process_log</span><span class='op'>(</span><span class='va'>worker_id</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_id</code></dt><dd><p>The worker for which the log is required</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_config_save"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_config_save()</code></h3>
<p>Save a worker configuration, which can be used to
start workers with a set of options with the cli. These
correspond to arguments to <a href='rrq_worker.html'>rrq_worker</a>.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_config_save</span><span class='op'>(</span>
  <span class='va'>name</span>,
  time_poll <span class='op'>=</span> <span class='cn'>NULL</span>,
  timeout <span class='op'>=</span> <span class='cn'>NULL</span>,
  queue <span class='op'>=</span> <span class='cn'>NULL</span>,
  heartbeat_period <span class='op'>=</span> <span class='cn'>NULL</span>,
  verbose <span class='op'>=</span> <span class='cn'>NULL</span>,
  overwrite <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>name</code></dt><dd><p>Name for this configuration</p></dd>

<dt><code>time_poll</code></dt><dd><p>Poll time.  Longer values here will reduce the
impact on the database but make workers less responsive to being
killed with an interrupt.  The default should be good for most
uses, but shorter values are used for debugging.</p></dd>

<dt><code>timeout</code></dt><dd><p>Optional timeout to set for the worker.  This is
(roughly) equivalent to issuing a <code>TIMEOUT_SET</code> message
after initialising the worker, except that it's guaranteed to be
run by all workers.</p></dd>

<dt><code>queue</code></dt><dd><p>Optional character vector of queues to listen on
for jobs. There is a default queue which is always listened
on (called 'default'). You can specify additional names here
and jobs put onto these queues with <code>$enqueue()</code> will have
<em>higher</em> priority than the default. You can explicitly list
the "default" queue (e.g., <code>queue = c("high", "default", "low")</code>) to set the position of the default queue.</p></dd>

<dt><code>heartbeat_period</code></dt><dd><p>Optional period for the heartbeat.  If
non-NULL then a heartbeat process will be started (using the
<code>heartbeatr</code> package) which can be used to build fault
tolerant queues.</p></dd>

<dt><code>verbose</code></dt><dd><p>Logical, indicating if the worker should print
logging output to the screen.  Logging to screen has a small but
measurable performance cost, and if you will not collect system
logs from the worker then it is wasted time.  Logging to the
redis server is always enabled.</p></dd>

<dt><code>overwrite</code></dt><dd><p>Logical, indicating if an existing configuration
with this <code>name</code> should be overwritten if it exists (if
<code>overwrite = FALSE</code> and the configuration exists an error will
be thrown).</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_config_list"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_config_list()</code></h3>
<p>Return names of worker configurations saved by
<code>$worker_config_save</code></p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_config_list</span><span class='op'>(</span><span class='op'>)</span></pre><p></div></p>

<p><hr>
<a id="method-worker_config_read"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_config_read()</code></h3>
<p>Return the value of a of worker configuration saved by
<code>$worker_config_save</code></p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_config_read</span><span class='op'>(</span><span class='va'>name</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>name</code></dt><dd><p>Name of the configuration
Report on worker "load" (the number of workers being used over
time). Reruns an object of class <code>worker_load</code>, for which a
<code>mean</code> method exists (this method is a work in progress and the
interface may change).</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-worker_load"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>worker_load()</code></h3>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>worker_load</span><span class='op'>(</span>worker_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers are used.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-message_send"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>message_send()</code></h3>
<p>Send a message to workers. Sending a message returns
a message id, which can be used to poll for a response with the
other <code>message_*</code> methods.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>message_send</span><span class='op'>(</span><span class='va'>command</span>, args <span class='op'>=</span> <span class='cn'>NULL</span>, worker_ids <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>command</code></dt><dd><p>A command, such as <code>PING</code>, <code>PAUSE</code>; see the Messages
section of the Details for al messages.</p></dd>

<dt><code>args</code></dt><dd><p>Arguments to the command, if supported</p></dd>

<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids to send the message
to. If <code>NULL</code> then the message will be sent to all active workers.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-message_has_response"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>message_has_response()</code></h3>
<p>Detect if a response is available for a message</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>message_has_response</span><span class='op'>(</span>
  <span class='va'>message_id</span>,
  worker_ids <span class='op'>=</span> <span class='cn'>NULL</span>,
  named <span class='op'>=</span> <span class='cn'>TRUE</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>message_id</code></dt><dd><p>The message id</p></dd>

<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers are used (note that this may differ to the set
of workers that the message was sent to!)</p></dd>

<dt><code>named</code></dt><dd><p>Logical, indicating if the return vector should be named</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-message_get_response"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>message_get_response()</code></h3>
<p>Get response to messages, waiting until the
message has been responded to.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>message_get_response</span><span class='op'>(</span>
  <span class='va'>message_id</span>,
  worker_ids <span class='op'>=</span> <span class='cn'>NULL</span>,
  named <span class='op'>=</span> <span class='cn'>TRUE</span>,
  delete <span class='op'>=</span> <span class='cn'>FALSE</span>,
  timeout <span class='op'>=</span> <span class='fl'>0</span>,
  time_poll <span class='op'>=</span> <span class='fl'>1</span>,
  progress <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>message_id</code></dt><dd><p>The message id</p></dd>

<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids. If <code>NULL</code> then
all active workers are used (note that this may differ to the set
of workers that the message was sent to!)</p></dd>

<dt><code>named</code></dt><dd><p>Logical, indicating if the return value should be
named by worker id.</p></dd>

<dt><code>delete</code></dt><dd><p>Logical, indicating if messages should be deleted
after retrieval</p></dd>

<dt><code>timeout</code></dt><dd><p>Integer, representing seconds to wait until the
response has been received. An error will be thrown if a
response has not been received in this time.</p></dd>

<dt><code>time_poll</code></dt><dd><p>If <code>timeout</code> is greater
than zero, this is the polling interval used between redis calls.
Increasing this reduces network load but increases the time that
may be waited for.</p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-message_response_ids"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>message_response_ids()</code></h3>
<p>Return ids for messages with responses for a
particular worker.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>message_response_ids</span><span class='op'>(</span><span class='va'>worker_id</span><span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>worker_id</code></dt><dd><p>The worker id</p></dd>

</dl><p></div></p>
<p><hr>
<a id="method-message_send_and_wait"></a></p><h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Method <code>message_send_and_wait()</code></h3>
<p>Send a message and wait for responses.
This is a helper function around <code>message_send</code> and
<code>message_get_response</code>.</p><h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Usage</h4>
<p><div class="r"></p><pre><span class='va'>rrq_controller_</span><span class='op'>$</span><span class='fu'>message_send_and_wait</span><span class='op'>(</span>
  <span class='va'>command</span>,
  args <span class='op'>=</span> <span class='cn'>NULL</span>,
  worker_ids <span class='op'>=</span> <span class='cn'>NULL</span>,
  named <span class='op'>=</span> <span class='cn'>TRUE</span>,
  delete <span class='op'>=</span> <span class='cn'>TRUE</span>,
  timeout <span class='op'>=</span> <span class='fl'>600</span>,
  time_poll <span class='op'>=</span> <span class='fl'>1</span>,
  progress <span class='op'>=</span> <span class='cn'>NULL</span>
<span class='op'>)</span></pre><p></div></p>

<h4 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>Arguments</h4>
<p><div class="arguments"></p><dl>
<dt><code>command</code></dt><dd><p>A command, such as <code>PING</code>, <code>PAUSE</code>; see the Messages
section of the Details for al messages.</p></dd>

<dt><code>args</code></dt><dd><p>Arguments to the command, if supported</p></dd>

<dt><code>worker_ids</code></dt><dd><p>Optional vector of worker ids to send the message
to. If <code>NULL</code> then the message will be sent to all active workers.</p></dd>

<dt><code>named</code></dt><dd><p>Logical, indicating if the return value should be
named by worker id.</p></dd>

<dt><code>delete</code></dt><dd><p>Logical, indicating if messages should be deleted
after retrieval</p></dd>

<dt><code>timeout</code></dt><dd><p>Integer, representing seconds to wait until the
response has been received. An error will be thrown if a
response has not been received in this time.</p></dd>

<dt><code>time_poll</code></dt><dd><p>If <code>timeout</code> is greater
than zero, this is the polling interval used between redis calls.
Increasing this reduces network load but increases the time that
may be waited for.</p></dd>

<dt><code>progress</code></dt><dd><p>Optional logical indicating if a progress bar
should be displayed. If <code>NULL</code> we fall back on the value of the
global option <code>rrq.progress</code>, and if that is unset display a
progress bar if in an interactive session.</p></dd>

</dl><p></div></p>



  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Rich FitzJohn.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


